diff --git a/agent.py b/agent.py
index 79f1a1a..fe3cef3 100644
--- a/agent.py
+++ b/agent.py
@@ -213,7 +213,7 @@ class Agent:
             self.assign_scout_port(G, new_leader, scout_pool)
         elif len(leaders) == 0:
             print(f'Electing leader for the first time. Round No {self.round_number}')
-        else:
+        else: # only one leader
             # the leader checks for next port to visit if exists otherwise backtrack; the helpers return to their home base.
             leader = leaders[0]
             scout_pool = [a for a in colocated_agents if a.state['status'] == AgentStatus["UNSETTLED"]]
@@ -228,12 +228,43 @@ class Agent:
                 else:
                     # go to the empty node with all unsettled followers
                     unsettled_followers = [a for a in scout_pool if a.state['status'] == AgentStatus["UNSETTLED"]]
-                    next_port = scout_returns[0].scout_port
-                    for a in unsettled_followers:
-                        a.next_port = next_port
-                        a.computed = True 
-                    leader.next_port = next_port
-                    leader.computed = True
+                    # find empty node
+                    empty_port = None
+                    empty_ports = [a.scout_port for a in scout_returns if a.scouted_result == NodeStatus["EMPTY"]]
+                    empty_port = min(empty_ports) if empty_ports else None
+                    if empty_port is not None:
+                        # if empty node is found, go to the empty node with all unsettled followers
+                        for a in unsettled_followers:
+                            a.next_port = empty_port
+                            a.state['phase'] = AgentPhase['EXPLORE']
+                            a.computed = True 
+                            a.scout_port = None
+                        leader.next_port = empty_port
+                        leader.state['phase'] = AgentPhase['EXPLORE']
+                        leader.computed = True
+                        leader.scout_port = None
+                    else: # no empty node found
+                        if leader.checked_port < G.degree(leader.currentnode):
+                            self.assign_scout_port(G, leader, scout_pool)
+                        else: # no more ports to check
+                            # go back to parent port at settled robot
+                            # find settled agent 
+                            settled_agent = [a for a in colocated_agents if a.state['status'] == AgentStatus["SETTLED"]][0]
+                            leader.next_port = settled_agent.parent_port
+                            leader.computed = True
+                            leader.scout_port = None
+                            for a in scout_pool:
+                                a.state['phase'] = AgentPhase['EXPLORE']
+                                a.next_port = settled_agent.parent_port
+                                a.computed = True
+                                a.scout_port = None
+            else: # no scout returns
+                if leader.state['phase'] == AgentPhase['EXPLORE']:
+                    settled_agent = self.settle_heo(G, leader)
+                    settled_agent.state['phase']= AgentPhase['WAIT_SCOUT']
+                    # leader will start scout()
+                    scout_pool = [a for a in colocated_agents if a != settled_agent]
+                    self.assign_scout_port(G, leader, scout_pool)
 
 
     def assign_scout_port(self, G, leader, scout_pool):
diff --git a/cytoscape-visualizer.js b/cytoscape-visualizer.js
index 06815b2..4d0c56f 100644
--- a/cytoscape-visualizer.js
+++ b/cytoscape-visualizer.js
@@ -85,7 +85,8 @@ export function drawCytoscape(containerId, data) {
     cy.ready(() => {
         addAgents(data.positions[0], data.statuses[0]);
         updateNodeStyles(data.positions[0], data.statuses[0]);
-        animateAgents(data.positions, data.statuses);
+        const animDuration = parseInt(document.getElementById('animationDurationInput').value, 10) || 200;
+        animateAgents(data.positions, data.statuses, animDuration);
     });
 }
 
@@ -121,11 +122,11 @@ function updateNodeStyles(positionsRound, statusesRound) {
     });
 }
 
-function animateAgents(positions, statuses) {
+function animateAgents(positions, statuses, animDuration) {
     let round = 1;
     const total = positions.length;
-    const duration = 800;
-    const pause = 1000;
+    const duration = animDuration || 200;
+    const pause = animDuration || 200;
 
     function step() {
         if (round >= total) {
@@ -151,5 +152,9 @@ function animateAgents(positions, statuses) {
         round++;
         animationTimeout = setTimeout(step, duration + pause);
     }
-    animationTimeout = setTimeout(step, 500);
+    animationTimeout = setTimeout(step, 100);
 }
+
+// Find where animateAgents is called and pass the animation duration from the input
+// Example: animateAgents(positions, statuses, parseInt(document.getElementById('animationDurationInput').value, 10) || 200);
+// If this is called elsewhere, update those calls accordingly.
diff --git a/graph_utils.py b/graph_utils.py
index fd3b669..fae4b69 100644
--- a/graph_utils.py
+++ b/graph_utils.py
@@ -3,14 +3,12 @@
 import networkx as nx
 import random
 
-def create_port_labeled_graph(nodes, edges):
+def create_port_labeled_graph(nodes, max_degree, seed):
     """
     Build an undirected graph where each node u has ports 0..deg(u)-1 
     mapped to its neighbors in arbitrary order.
     """
-    G = nx.Graph()
-    G.add_nodes_from(range(nodes))
-    G.add_edges_from(edges)
+    G = nx.random_regular_graph(max_degree, nodes, seed = seed)
 
     for u in G.nodes():
         neighs = list(G.neighbors(u))
diff --git a/index.html b/index.html
index a5779ea..5949436 100644
--- a/index.html
+++ b/index.html
@@ -18,14 +18,16 @@
   <h1>CCM Simulation in Pyodide</h1>
   <div id="controls">
     <label>Nodes<input type="number" id="nodeCountInput" min="1" value="10"></label>
-    <label>Max Deg<input type="number" id="maxDegreeInput" min="1" value="4"></label>
-    <label>Agents<input type="number" id="agentCountInput" min="1" value="3"></label>
-    <label>Rounds<input type="number" id="roundCountInput" min="1" value="3"></label>
+    <label>Max Deg<input type="number" id="maxDegreeInput" min="1" value="4"></label>
+    <label>Agents<input type="number" id="agentCountInput" min="1" value="8"></label>
+    <label>Rounds<input type="number" id="roundCountInput" min="1" value="20"></label>
+    <label>Anim Duration (ms)<input type="number" id="animationDurationInput" min="100" value="300"  step="100"></label>
+    <label>Seed<input type="number" id="seedInput" value="42"></label>
     <button id="runBtn">Run</button>
   </div>
 
   <div id="output">Click “Run” to start.</div>
-  <div id="round-display">Round: 0</div>
+  <div id="round-display">Round: 0</div>
   <div id="cy"></div>
 
   <script src="https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js"></script>
diff --git a/main.js b/main.js
index ea22a64..599fa65 100644
--- a/main.js
+++ b/main.js
@@ -4,62 +4,97 @@ import { pyodideReady } from './pyodide-setup.js';
 import { runSimulation } from './simulation-runner.js';
 import { drawCytoscape } from './cytoscape-visualizer.js';
 
+console.log("main.js: Script start."); // Log script execution start
+
 // Simplified input validation
 function getVal(input, def, min) {
-  let v = parseInt(input.value, 10);
-  if (isNaN(v) || v < min) { input.value = def; return def; }
-  return v;
+    let v = parseInt(input.value, 10);
+    if (isNaN(v) || v < min) {
+        console.warn(`main.js: Invalid input value in ${input.id}. Resetting to default ${def}.`);
+        input.value = def;
+        return def;
+    }
+    return v;
 }
 
-const btn = document.getElementById('runBtn');
-const out = document.getElementById('output');
-const cyId = 'cy';
-
-btn.onclick = async () => {
-  btn.disabled = true;
-  out.textContent = 'Loading…';
-  try {
-    const py = await pyodideReady;
-    out.textContent = 'Running…';
-
-    const n = getVal(document.getElementById('nodeCountInput'), 10, 1);
-    const d = Math.min(getVal(document.getElementById('maxDegreeInput'), 4, 1), n - 1);
-    const a = getVal(document.getElementById('agentCountInput'), 3, 1);
-    const r = getVal(document.getElementById('roundCountInput'), 10, 1);
-
-    out.textContent = `Gen graph: ${n} nodes, maxDeg ${d}, agents ${a}, rounds ${r}`;
-    const edges = generateRandomGraphEdges(n, d);
-
-    const data = await runSimulation(py, n, edges, a, r);
-    if (!data.positions || !data.statuses) throw new Error('Bad data');
-
-    drawCytoscape(cyId, data);
-    out.textContent = `Displayed ${data.positions.length-1} rounds. Green = SETTLED.`;
-  } catch (err) {
-    console.error(err);
-    out.textContent = `Error: ${err.message}`;
-  } finally {
-    btn.disabled = false;
-  }
-};
-
-// same generateRandomGraphEdges as before…
-function generateRandomGraphEdges(numNodes, maxDegree) {
-  if (maxDegree >= numNodes) maxDegree = numNodes - 1;
-  const pairs = [];
-  for (let i = 0; i < numNodes; i++)
-    for (let j = i+1; j < numNodes; j++)
-      pairs.push([i,j]);
-  for (let i = pairs.length-1; i>0; i--) {
-    const j = Math.floor(Math.random()*(i+1));
-    [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
-  }
-  const deg = Array(numNodes).fill(0), edges = [];
-  for (let [u,v] of pairs) {
-    if (deg[u]<maxDegree && deg[v]<maxDegree) {
-      edges.push([u,v]);
-      deg[u]++; deg[v]++;
+// --- Wait for the DOM to be fully loaded ---
+// Although type="module" and script at end often suffice, let's be explicit
+document.addEventListener('DOMContentLoaded', () => {
+    console.log("main.js: DOM fully loaded and parsed.");
+
+    const btn = document.getElementById('runBtn');
+    const out = document.getElementById('output');
+    const cyId = 'cy';
+
+    if (!btn) {
+        console.error("main.js: CRITICAL - Could not find button #runBtn after DOMContentLoaded.");
+        out.textContent = "Error: Button element not found.";
+        return; // Stop if button isn't found
+    } else {
+        console.log("main.js: Found button #runBtn:", btn);
     }
-  }
-  return edges;
-}
+
+    if (!out) {
+        console.warn("main.js: Could not find output element #output.");
+    }
+
+    // --- Define the click handler function ---
+    const handleRunClick = async () => {
+        console.log("main.js: handleRunClick invoked!"); // <-- *** THIS IS THE KEY LOG TO LOOK FOR ON CLICK ***
+        if (btn.disabled) {
+            console.log("main.js: Click ignored, button is already disabled.");
+            return; // Prevent re-entry if already running
+        }
+
+        btn.disabled = true;
+        if (out) out.textContent = 'Loading…';
+        console.log("main.js: Button disabled, text set to Loading...");
+
+        try {
+            console.log("main.js: Waiting for pyodideReady...");
+            const py = await pyodideReady;
+            console.log("main.js: Pyodide ready.");
+            if (out) out.textContent = 'Running…';
+
+            const n = getVal(document.getElementById('nodeCountInput'), 10, 1);
+            const d = Math.min(getVal(document.getElementById('maxDegreeInput'), 4, 1), n - 1);
+            const a = getVal(document.getElementById('agentCountInput'), 3, 1);
+            const r = getVal(document.getElementById('roundCountInput'), 10, 1);
+            const seed = parseInt(document.getElementById('seedInput').value, 10) || 42;
+            console.log(`main.js: Parameters - n=${n}, d=${d}, a=${a}, r=${r}, seed=${seed}`);
+
+            if (out) out.textContent = `Gen graph: ${n} nodes, maxDeg ${d}, agents ${a}, rounds ${r}, seed ${seed}`;
+            console.log("main.js: Calling runSimulation...");
+            const data = await runSimulation(py, n, d, a, r, seed);
+            console.log("main.js: runSimulation returned.");
+
+            if (!data || !data.positions || !data.statuses) {
+                 throw new Error('Bad data received from runSimulation');
+            }
+            console.log("main.js: Simulation data looks okay. Calling drawCytoscape...");
+            drawCytoscape(cyId, data);
+            console.log("main.js: drawCytoscape finished.");
+            if (out) out.textContent = `Displayed ${data.positions.length - 1} rounds. Green = SETTLED.`;
+
+        } catch (err) {
+            console.error("main.js: Error during handleRunClick execution:", err);
+            if (out) out.textContent = `Error: ${err.message}`;
+        } finally {
+            console.log("main.js: Re-enabling button.");
+            btn.disabled = false;
+        }
+    };
+
+    // --- Attach the event listener ---
+    // Remove potentially existing listener first (safer if script re-runs)
+    btn.removeEventListener('click', handleRunClick);
+    // Add the listener
+    btn.addEventListener('click', handleRunClick);
+    console.log("main.js: Attached click listener to #runBtn.");
+
+    // Initial message
+    if (out) out.textContent = 'Click “Run” to start.';
+
+}); // End of DOMContentLoaded listener
+
+console.log("main.js: Script end."); // Log script execution end
\ No newline at end of file
diff --git a/simulation-runner.js b/simulation-runner.js
index 288f619..f94b3dd 100644
--- a/simulation-runner.js
+++ b/simulation-runner.js
@@ -7,7 +7,7 @@ async function loadPyFile(py, fname) {
     py.FS.writeFile(fname, text);
   }
   
-  export async function runSimulation(py, nodes, edges, agents, rounds) {
+  export async function runSimulation(py, nodes, max_degree, agents, rounds, seed) {
     // Load all Python modules and helper script into Pyodide FS
     const pythonFiles = [
       'graph_utils.py',
@@ -20,8 +20,7 @@ async function loadPyFile(py, fname) {
     let script = py.FS.readFile('simulation_wrapper.py', { encoding: 'utf8' });
   
     // Inject runtime parameters at the top
-    const header = `nodes = ${nodes}\nedges = ${JSON.stringify(edges)}\n` +
-                   `agent_count = ${agents}\nrounds = ${rounds}\n`;
+    const header = `nodes = ${nodes}\nagent_count = ${agents}\nrounds = ${rounds}\nseed = ${seed}\nmax_degree = ${max_degree}\n`;
     script = header + script;
   
     // Execute the Python script and parse JSON output
diff --git a/simulation_wrapper.py b/simulation_wrapper.py
index 15127be..f254769 100644
--- a/simulation_wrapper.py
+++ b/simulation_wrapper.py
@@ -31,10 +31,10 @@ def run_simulation(G, agents, rounds):
         all_statuses.append(statuses)
     return all_positions, all_statuses
 
-# "nodes", "edges", "agent_count", and "rounds" are provided by the runner
+# "nodes", "max degree", "agent_count", and "rounds" are provided by the runner
 
-# Build and label graph ports
-G = create_port_labeled_graph(nodes, edges)
+G = create_port_labeled_graph(nodes, max_degree, seed)
+print(f'Graph created with {G.number_of_nodes()} nodes and {G.number_of_edges()} edges')
 randomize_ports(G)
 for node in G.nodes():
     G.nodes[node]['agents'] = set()
